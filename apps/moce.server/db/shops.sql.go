// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: shops.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countChannels = `-- name: CountChannels :one
SELECT 
  (
    SELECT COUNT(*) FROM "salesChannels"
    WHERE
      "shopId" = $1
  ) "totalShopChannels"
`

func (q *Queries) CountChannels(ctx context.Context, shopid string) (int64, error) {
	row := q.db.QueryRow(ctx, countChannels, shopid)
	var totalShopChannels int64
	err := row.Scan(&totalShopChannels)
	return totalShopChannels, err
}

const countShops = `-- name: CountShops :one
SELECT
  (
    SELECT COUNT(*) FROM shops
    WHERE
      shops."userId" = $1 AND
      shops.deleted IS NULL
  ) "totalShops",
  (
    SELECT COUNT(*) FROM shops
    WHERE
      shops."userId" = $1 AND
      shops.deleted IS NOT NULL
  ) "totalDeletedShops"
`

type CountShopsRow struct {
	TotalShops        int64 `json:"totalShops"`
	TotalDeletedShops int64 `json:"totalDeletedShops"`
}

func (q *Queries) CountShops(ctx context.Context, userid string) (CountShopsRow, error) {
	row := q.db.QueryRow(ctx, countShops, userid)
	var i CountShopsRow
	err := row.Scan(&i.TotalShops, &i.TotalDeletedShops)
	return i, err
}

const deleteChannel = `-- name: DeleteChannel :exec
DELETE FROM "salesChannels"
WHERE
  "shopId" = $1 AND
  id = $2
`

type DeleteChannelParams struct {
	ShopId string `json:"shopId"`
	ID     string `json:"id"`
}

func (q *Queries) DeleteChannel(ctx context.Context, arg DeleteChannelParams) error {
	_, err := q.db.Exec(ctx, deleteChannel, arg.ShopId, arg.ID)
	return err
}

const deleteShop = `-- name: DeleteShop :exec
DELETE FROM shops
WHERE
  "userId" = $1 AND
  id = $2
`

type DeleteShopParams struct {
	UserId string `json:"userId"`
	ID     string `json:"id"`
}

func (q *Queries) DeleteShop(ctx context.Context, arg DeleteShopParams) error {
	_, err := q.db.Exec(ctx, deleteShop, arg.UserId, arg.ID)
	return err
}

const getChannel = `-- name: GetChannel :one
SELECT DISTINCT id, created, updated, name, typ, active, "shopId" FROM "salesChannels" 
WHERE
  "shopId" = $1 AND
  id = $2
LIMIT 1
`

type GetChannelParams struct {
	ShopId string `json:"shopId"`
	ID     string `json:"id"`
}

func (q *Queries) GetChannel(ctx context.Context, arg GetChannelParams) (SalesChannel, error) {
	row := q.db.QueryRow(ctx, getChannel, arg.ShopId, arg.ID)
	var i SalesChannel
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Updated,
		&i.Name,
		&i.Typ,
		&i.Active,
		&i.ShopId,
	)
	return i, err
}

const getChannels = `-- name: GetChannels :many
SELECT id, created, updated, name, typ, active, "shopId" FROM "salesChannels"
WHERE
  "shopId" = $1 AND
  id = $2
LIMIT COALESCE($1, 10)
`

type GetChannelsParams struct {
	ShopId string `json:"shopId"`
	ID     string `json:"id"`
}

func (q *Queries) GetChannels(ctx context.Context, arg GetChannelsParams) ([]SalesChannel, error) {
	rows, err := q.db.Query(ctx, getChannels, arg.ShopId, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SalesChannel
	for rows.Next() {
		var i SalesChannel
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Updated,
			&i.Name,
			&i.Typ,
			&i.Active,
			&i.ShopId,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeletedShops = `-- name: GetDeletedShops :many
SELECT id, created, updated, deleted, name, "desc", currency, "weightUnit", "userId" FROM shops
WHERE
  "userId" = $1 AND
  deleted IS NOT NULL
LIMIT COALESCE($2, 10)
`

type GetDeletedShopsParams struct {
	UserId string      `json:"userId"`
	Limit  interface{} `json:"limit"`
}

func (q *Queries) GetDeletedShops(ctx context.Context, arg GetDeletedShopsParams) ([]Shop, error) {
	rows, err := q.db.Query(ctx, getDeletedShops, arg.UserId, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Shop
	for rows.Next() {
		var i Shop
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Updated,
			&i.Deleted,
			&i.Name,
			&i.Desc,
			&i.Currency,
			&i.WeightUnit,
			&i.UserId,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShop = `-- name: GetShop :one
SELECT DISTINCT id, created, updated, deleted, name, "desc", currency, "weightUnit", "userId" FROM shops
WHERE
  "userId" = $1 AND
  id = $2 AND
  deleted IS NULL
LIMIT 1
`

type GetShopParams struct {
	UserId string `json:"userId"`
	ID     string `json:"id"`
}

func (q *Queries) GetShop(ctx context.Context, arg GetShopParams) (Shop, error) {
	row := q.db.QueryRow(ctx, getShop, arg.UserId, arg.ID)
	var i Shop
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Updated,
		&i.Deleted,
		&i.Name,
		&i.Desc,
		&i.Currency,
		&i.WeightUnit,
		&i.UserId,
	)
	return i, err
}

const getShops = `-- name: GetShops :many
SELECT id, created, updated, deleted, name, "desc", currency, "weightUnit", "userId" FROM shops
WHERE
  "userId" = $1 AND
  deleted IS NULL
LIMIT COALESCE($2, 10)
`

type GetShopsParams struct {
	UserId string      `json:"userId"`
	Limit  interface{} `json:"limit"`
}

func (q *Queries) GetShops(ctx context.Context, arg GetShopsParams) ([]Shop, error) {
	rows, err := q.db.Query(ctx, getShops, arg.UserId, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Shop
	for rows.Next() {
		var i Shop
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Updated,
			&i.Deleted,
			&i.Name,
			&i.Desc,
			&i.Currency,
			&i.WeightUnit,
			&i.UserId,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveChannel = `-- name: SaveChannel :one
INSERT INTO "salesChannels" (
  id, updated, name, typ, active, "shopId"
)
VALUES (
  $1, NOW(), $2, $3, $4, $5
)
ON CONFLICT (id)
DO UPDATE SET
  name = EXCLUDED.name,
  typ = EXCLUDED.typ,
  active = EXCLUDED.active,
  "shopId" = EXCLUDED."shopId"
RETURNING id, created, updated, name, typ, active, "shopId"
`

type SaveChannelParams struct {
	ID     string `json:"id"`
	Name   string `json:"name"`
	Typ    string `json:"typ"`
	Active bool   `json:"active"`
	ShopId string `json:"shopId"`
}

func (q *Queries) SaveChannel(ctx context.Context, arg SaveChannelParams) (SalesChannel, error) {
	row := q.db.QueryRow(ctx, saveChannel,
		arg.ID,
		arg.Name,
		arg.Typ,
		arg.Active,
		arg.ShopId,
	)
	var i SalesChannel
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Updated,
		&i.Name,
		&i.Typ,
		&i.Active,
		&i.ShopId,
	)
	return i, err
}

const saveShop = `-- name: SaveShop :one
INSERT INTO shops (
  id, updated, deleted, name, "desc", 
  currency, "weightUnit", "userId"
)
VALUES (
  $1, NOW(), $2, $3, $4,
  $5, $6, $7
)
ON CONFLICT (id)
DO UPDATE SET
  deleted = EXCLUDED.deleted,
  name = EXCLUDED.name,
  "desc" = EXCLUDED."desc",
  currency = EXCLUDED.currency,
  "weightUnit" = EXCLUDED."weightUnit",
  "userId" = EXCLUDED."userId"
RETURNING id, created, updated, deleted, name, "desc", currency, "weightUnit", "userId"
`

type SaveShopParams struct {
	ID         string           `json:"id"`
	Deleted    pgtype.Timestamp `json:"deleted"`
	Name       string           `json:"name"`
	Desc       string           `json:"desc"`
	Currency   string           `json:"currency"`
	WeightUnit string           `json:"weightUnit"`
	UserId     string           `json:"userId"`
}

func (q *Queries) SaveShop(ctx context.Context, arg SaveShopParams) (Shop, error) {
	row := q.db.QueryRow(ctx, saveShop,
		arg.ID,
		arg.Deleted,
		arg.Name,
		arg.Desc,
		arg.Currency,
		arg.WeightUnit,
		arg.UserId,
	)
	var i Shop
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Updated,
		&i.Deleted,
		&i.Name,
		&i.Desc,
		&i.Currency,
		&i.WeightUnit,
		&i.UserId,
	)
	return i, err
}

const softDeleteShop = `-- name: SoftDeleteShop :exec
UPDATE shops 
SET 
  deleted = NOW()
WHERE
  "userId" = $1 AND
  id = $2
`

type SoftDeleteShopParams struct {
	UserId string `json:"userId"`
	ID     string `json:"id"`
}

func (q *Queries) SoftDeleteShop(ctx context.Context, arg SoftDeleteShopParams) error {
	_, err := q.db.Exec(ctx, softDeleteShop, arg.UserId, arg.ID)
	return err
}
