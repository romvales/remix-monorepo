// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: collections.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countCollections = `-- name: CountCollections :one
SELECT
  (
    SELECT COUNT(*) FROM collections 
    WHERE 
      collections.deleted IS NULL AND 
      collections."shopId" = $1
  ) "totalCollections",
  (
    SELECT COUNT(*) FROM collections 
    WHERE 
      collections.deleted IS NOT NULL AND 
      collections."shopId" = $1
  ) "totalDeletedCollections"
`

type CountCollectionsRow struct {
	TotalCollections        int64 `json:"totalCollections"`
	TotalDeletedCollections int64 `json:"totalDeletedCollections"`
}

func (q *Queries) CountCollections(ctx context.Context, shopid string) (CountCollectionsRow, error) {
	row := q.db.QueryRow(ctx, countCollections, shopid)
	var i CountCollectionsRow
	err := row.Scan(&i.TotalCollections, &i.TotalDeletedCollections)
	return i, err
}

const deleteCollection = `-- name: DeleteCollection :exec
DELETE FROM collections 
WHERE
  id = $1 AND
  "shopId" = $2
`

type DeleteCollectionParams struct {
	ID     string `json:"id"`
	ShopId string `json:"shopId"`
}

func (q *Queries) DeleteCollection(ctx context.Context, arg DeleteCollectionParams) error {
	_, err := q.db.Exec(ctx, deleteCollection, arg.ID, arg.ShopId)
	return err
}

const getCollection = `-- name: GetCollection :one
SELECT DISTINCT id, created, updated, deleted, published, "isPublish", sort, title, "desc", "shopId" FROM collections 
WHERE 
  id = $1 AND
  "shopId" = $2
LIMIT 1
`

type GetCollectionParams struct {
	ID     string `json:"id"`
	ShopId string `json:"shopId"`
}

func (q *Queries) GetCollection(ctx context.Context, arg GetCollectionParams) (Collection, error) {
	row := q.db.QueryRow(ctx, getCollection, arg.ID, arg.ShopId)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Updated,
		&i.Deleted,
		&i.Published,
		&i.IsPublish,
		&i.Sort,
		&i.Title,
		&i.Desc,
		&i.ShopId,
	)
	return i, err
}

const getCollections = `-- name: GetCollections :many
SELECT id, created, updated, deleted, published, "isPublish", sort, title, "desc", "shopId" FROM collections
WHERE
  deleted IS NULL AND
  "shopId" = $1
LIMIT COALESCE($2, 10)
`

type GetCollectionsParams struct {
	ShopId string      `json:"shopId"`
	Limit  interface{} `json:"limit"`
}

func (q *Queries) GetCollections(ctx context.Context, arg GetCollectionsParams) ([]Collection, error) {
	rows, err := q.db.Query(ctx, getCollections, arg.ShopId, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Collection
	for rows.Next() {
		var i Collection
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Updated,
			&i.Deleted,
			&i.Published,
			&i.IsPublish,
			&i.Sort,
			&i.Title,
			&i.Desc,
			&i.ShopId,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeletedCollections = `-- name: GetDeletedCollections :many
SELECT id, created, updated, deleted, published, "isPublish", sort, title, "desc", "shopId" FROM collections
WHERE
  deleted IS NOT NULL AND
  "shopId" = $1
LIMIT COALESCE($2, 10)
`

type GetDeletedCollectionsParams struct {
	ShopId string      `json:"shopId"`
	Limit  interface{} `json:"limit"`
}

func (q *Queries) GetDeletedCollections(ctx context.Context, arg GetDeletedCollectionsParams) ([]Collection, error) {
	rows, err := q.db.Query(ctx, getDeletedCollections, arg.ShopId, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Collection
	for rows.Next() {
		var i Collection
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Updated,
			&i.Deleted,
			&i.Published,
			&i.IsPublish,
			&i.Sort,
			&i.Title,
			&i.Desc,
			&i.ShopId,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveCollection = `-- name: SaveCollection :one
INSERT INTO collections (
  id, updated, deleted, published,
  "isPublish", sort, title, "desc",
  "shopId"
)
VALUES (
  $1, NOW(), $2, $3, $4,
  $5, $6, $7,
  $8
)
ON CONFLICT (id)
DO UPDATE SET
  deleted = EXCLUDED.deleted,
  published = EXCLUDED.published,
  "isPublish" = EXCLUDED."isPublish",
  sort = EXCLUDED.sort,
  title = EXCLUDED.title,
  "desc" = EXCLUDED."desc"
RETURNING id, created, updated, deleted, published, "isPublish", sort, title, "desc", "shopId"
`

type SaveCollectionParams struct {
	ID        string           `json:"id"`
	Deleted   pgtype.Timestamp `json:"deleted"`
	Published pgtype.Timestamp `json:"published"`
	IsPublish bool             `json:"isPublish"`
	Sort      pgtype.Text      `json:"sort"`
	Title     string           `json:"title"`
	Desc      pgtype.Text      `json:"desc"`
	ShopId    string           `json:"shopId"`
}

func (q *Queries) SaveCollection(ctx context.Context, arg SaveCollectionParams) (Collection, error) {
	row := q.db.QueryRow(ctx, saveCollection,
		arg.ID,
		arg.Deleted,
		arg.Published,
		arg.IsPublish,
		arg.Sort,
		arg.Title,
		arg.Desc,
		arg.ShopId,
	)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Updated,
		&i.Deleted,
		&i.Published,
		&i.IsPublish,
		&i.Sort,
		&i.Title,
		&i.Desc,
		&i.ShopId,
	)
	return i, err
}

const softDeleteCollection = `-- name: SoftDeleteCollection :exec
UPDATE collections SET deleted = NOW() 
WHERE 
  id = $1 AND
  "shopId" = $2
`

type SoftDeleteCollectionParams struct {
	ID     string `json:"id"`
	ShopId string `json:"shopId"`
}

func (q *Queries) SoftDeleteCollection(ctx context.Context, arg SoftDeleteCollectionParams) error {
	_, err := q.db.Exec(ctx, softDeleteCollection, arg.ID, arg.ShopId)
	return err
}
