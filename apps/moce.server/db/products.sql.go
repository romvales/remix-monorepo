// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: products.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countProducts = `-- name: CountProducts :one
SELECT
  (
    SELECT COUNT(*) FROM products
    WHERE
      products.deleted IS NULL AND
      products."shopId" = $1
  ) "totalProducts",
  (
    SELECT COUNT(*) FROM products
    WHERE
      products.deleted IS NOT NULL AND
      products."shopId" = $1
  ) "totalDeletedProducts"
`

type CountProductsRow struct {
	TotalProducts        int64 `json:"totalProducts"`
	TotalDeletedProducts int64 `json:"totalDeletedProducts"`
}

func (q *Queries) CountProducts(ctx context.Context, shopid string) (CountProductsRow, error) {
	row := q.db.QueryRow(ctx, countProducts, shopid)
	var i CountProductsRow
	err := row.Scan(&i.TotalProducts, &i.TotalDeletedProducts)
	return i, err
}

const deleteProduct = `-- name: DeleteProduct :exec
DELETE FROM products 
WHERE 
  id = $1 AND
  "shopId" = $2
`

type DeleteProductParams struct {
	ID     string `json:"id"`
	ShopId string `json:"shopId"`
}

func (q *Queries) DeleteProduct(ctx context.Context, arg DeleteProductParams) error {
	_, err := q.db.Exec(ctx, deleteProduct, arg.ID, arg.ShopId)
	return err
}

const getDeletedProducts = `-- name: GetDeletedProducts :many
SELECT id, created, updated, deleted, archived, published, status, title, type, tags, "shopId" FROM products
WHERE
  "shopId" = $1
LIMIT COALESCE($2, 10)
`

type GetDeletedProductsParams struct {
	ShopId string      `json:"shopId"`
	Limit  interface{} `json:"limit"`
}

func (q *Queries) GetDeletedProducts(ctx context.Context, arg GetDeletedProductsParams) ([]Product, error) {
	rows, err := q.db.Query(ctx, getDeletedProducts, arg.ShopId, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Updated,
			&i.Deleted,
			&i.Archived,
			&i.Published,
			&i.Status,
			&i.Title,
			&i.Type,
			&i.Tags,
			&i.ShopId,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProduct = `-- name: GetProduct :one
SELECT id, created, updated, deleted, archived, published, status, title, type, tags, "shopId" FROM products 
WHERE 
  id = $1
`

func (q *Queries) GetProduct(ctx context.Context, id string) (Product, error) {
	row := q.db.QueryRow(ctx, getProduct, id)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Updated,
		&i.Deleted,
		&i.Archived,
		&i.Published,
		&i.Status,
		&i.Title,
		&i.Type,
		&i.Tags,
		&i.ShopId,
	)
	return i, err
}

const getProducts = `-- name: GetProducts :many
SELECT id, created, updated, deleted, archived, published, status, title, type, tags, "shopId" FROM products
WHERE
  "shopId" = $1
LIMIT COALESCE($2, 10)
`

type GetProductsParams struct {
	ShopId string      `json:"shopId"`
	Limit  interface{} `json:"limit"`
}

func (q *Queries) GetProducts(ctx context.Context, arg GetProductsParams) ([]Product, error) {
	rows, err := q.db.Query(ctx, getProducts, arg.ShopId, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Updated,
			&i.Deleted,
			&i.Archived,
			&i.Published,
			&i.Status,
			&i.Title,
			&i.Type,
			&i.Tags,
			&i.ShopId,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveProduct = `-- name: SaveProduct :one
INSERT INTO products (
  id,
  updated,
  deleted,
  archived,
  published,
  status,
  title,
  type,
  tags,
  "shopId"
) VALUES (
  $1,
  NOW(),
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9
)
ON CONFLICT (id)
DO UPDATE SET
  updated = EXCLUDED.updated,
  deleted = EXCLUDED.deleted,
  archived = EXCLUDED.archived,
  published = EXCLUDED.published,
  status = EXCLUDED.status,
  title = EXCLUDED.title,
  type = EXCLUDED.type,
  tags = EXCLUDED.tags,
  "shopId" = EXCLUDED."shopId"
RETURNING id, created, updated, deleted, archived, published, status, title, type, tags, "shopId"
`

type SaveProductParams struct {
	ID        string           `json:"id"`
	Deleted   pgtype.Timestamp `json:"deleted"`
	Archived  pgtype.Timestamp `json:"archived"`
	Published pgtype.Timestamp `json:"published"`
	Status    ProductStatus    `json:"status"`
	Title     string           `json:"title"`
	Type      pgtype.Text      `json:"type"`
	Tags      []string         `json:"tags"`
	ShopId    string           `json:"shopId"`
}

func (q *Queries) SaveProduct(ctx context.Context, arg SaveProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, saveProduct,
		arg.ID,
		arg.Deleted,
		arg.Archived,
		arg.Published,
		arg.Status,
		arg.Title,
		arg.Type,
		arg.Tags,
		arg.ShopId,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Updated,
		&i.Deleted,
		&i.Archived,
		&i.Published,
		&i.Status,
		&i.Title,
		&i.Type,
		&i.Tags,
		&i.ShopId,
	)
	return i, err
}

const softDeleteProduct = `-- name: SoftDeleteProduct :exec
UPDATE products SET deleted = NOW(), updated = NOW()
WHERE 
  id = $1 AND
  "shopId" = $2
`

type SoftDeleteProductParams struct {
	ID     string `json:"id"`
	ShopId string `json:"shopId"`
}

func (q *Queries) SoftDeleteProduct(ctx context.Context, arg SoftDeleteProductParams) error {
	_, err := q.db.Exec(ctx, softDeleteProduct, arg.ID, arg.ShopId)
	return err
}
