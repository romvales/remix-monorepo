// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: customers.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addCustomerAddress = `-- name: AddCustomerAddress :one
INSERT INTO "customersAddresses" (
  id,
  updated,
  name,
  position,
  company,
  country,
  state,
  city,
  zip,
  addresses,
  phone,
  "customerId"
) VALUES (
  $1,
  NOW(),
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9,
  $10,
  $11
)
ON CONFLICT (id)
DO UPDATE SET
  updated = EXCLUDED.updated,
  name = EXCLUDED.name,
  position = EXCLUDED.position,
  company = EXCLUDED.company,
  country = EXCLUDED.country,
  state = EXCLUDED.state,
  city = EXCLUDED.city,
  zip = EXCLUDED.zip,
  addresses = EXCLUDED.addresses,
  phone = EXCLUDED.phone,
  "customerId" = EXCLUDED."customerId"
RETURNING id, created, updated, name, company, country, state, city, zip, addresses, phone, "customerId", position
`

type AddCustomerAddressParams struct {
	ID         string      `json:"id"`
	Name       string      `json:"name"`
	Position   int32       `json:"position"`
	Company    pgtype.Text `json:"company"`
	Country    pgtype.Text `json:"country"`
	State      pgtype.Text `json:"state"`
	City       pgtype.Text `json:"city"`
	Zip        pgtype.Text `json:"zip"`
	Addresses  []string    `json:"addresses"`
	Phone      pgtype.Text `json:"phone"`
	CustomerId string      `json:"customerId"`
}

func (q *Queries) AddCustomerAddress(ctx context.Context, arg AddCustomerAddressParams) (CustomersAddress, error) {
	row := q.db.QueryRow(ctx, addCustomerAddress,
		arg.ID,
		arg.Name,
		arg.Position,
		arg.Company,
		arg.Country,
		arg.State,
		arg.City,
		arg.Zip,
		arg.Addresses,
		arg.Phone,
		arg.CustomerId,
	)
	var i CustomersAddress
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Updated,
		&i.Name,
		&i.Company,
		&i.Country,
		&i.State,
		&i.City,
		&i.Zip,
		&i.Addresses,
		&i.Phone,
		&i.CustomerId,
		&i.Position,
	)
	return i, err
}

const countCustomers = `-- name: CountCustomers :one
SELECT
  (
    SELECT COUNT(*) FROM customers 
    WHERE 
      customers."ownerId" = $1 AND 
      deleted IS NULL) "totalCustomers",
  (
    SELECT COUNT(*) FROM customers 
    WHERE 
      customers."ownerId" = $1 AND 
      deleted IS NOT NULL) "totalDeletedCustomers"
`

type CountCustomersRow struct {
	TotalCustomers        int64 `json:"totalCustomers"`
	TotalDeletedCustomers int64 `json:"totalDeletedCustomers"`
}

func (q *Queries) CountCustomers(ctx context.Context, ownerid string) (CountCustomersRow, error) {
	row := q.db.QueryRow(ctx, countCustomers, ownerid)
	var i CountCustomersRow
	err := row.Scan(&i.TotalCustomers, &i.TotalDeletedCustomers)
	return i, err
}

const deleteCustomer = `-- name: DeleteCustomer :exec
DELETE FROM customers
WHERE
  "ownerId" = $1 AND
  (
    id = $2 OR
    email = $3
  )
`

type DeleteCustomerParams struct {
	Ownerid string `json:"ownerid"`
	ID      string `json:"id"`
	Email   string `json:"email"`
}

func (q *Queries) DeleteCustomer(ctx context.Context, arg DeleteCustomerParams) error {
	_, err := q.db.Exec(ctx, deleteCustomer, arg.Ownerid, arg.ID, arg.Email)
	return err
}

const getCustomer = `-- name: GetCustomer :one
SELECT DISTINCT id, created, updated, deleted, "fullName", email, phone, tags, note, "taxExempt", "ownerId" FROM customers WHERE
  "ownerId" = $1 AND
  (
    id = $2 OR
    email = $3 OR
    "fullName" = $4
  )
LIMIT 1
`

type GetCustomerParams struct {
	Ownerid  string `json:"ownerid"`
	ID       string `json:"id"`
	Email    string `json:"email"`
	Fullname string `json:"fullname"`
}

func (q *Queries) GetCustomer(ctx context.Context, arg GetCustomerParams) (Customer, error) {
	row := q.db.QueryRow(ctx, getCustomer,
		arg.Ownerid,
		arg.ID,
		arg.Email,
		arg.Fullname,
	)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Updated,
		&i.Deleted,
		&i.FullName,
		&i.Email,
		&i.Phone,
		&i.Tags,
		&i.Note,
		&i.TaxExempt,
		&i.OwnerId,
	)
	return i, err
}

const getCustomers = `-- name: GetCustomers :many
SELECT id, created, updated, deleted, "fullName", email, phone, tags, note, "taxExempt", "ownerId" FROM customers
WHERE
  "ownerId" = $1 AND
  deleted IS NULL
LIMIT COALESCE($2, 10)
`

type GetCustomersParams struct {
	Ownerid string      `json:"ownerid"`
	Limit   interface{} `json:"limit"`
}

func (q *Queries) GetCustomers(ctx context.Context, arg GetCustomersParams) ([]Customer, error) {
	rows, err := q.db.Query(ctx, getCustomers, arg.Ownerid, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Customer
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Updated,
			&i.Deleted,
			&i.FullName,
			&i.Email,
			&i.Phone,
			&i.Tags,
			&i.Note,
			&i.TaxExempt,
			&i.OwnerId,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeletedCustomers = `-- name: GetDeletedCustomers :many
SELECT id, created, updated, deleted, "fullName", email, phone, tags, note, "taxExempt", "ownerId" FROM customers
WHERE
  "ownerId" = $1 AND
  deleted IS NOT NULL
LIMIT COALESCE($2, 10)
`

type GetDeletedCustomersParams struct {
	Ownerid string      `json:"ownerid"`
	Limit   interface{} `json:"limit"`
}

func (q *Queries) GetDeletedCustomers(ctx context.Context, arg GetDeletedCustomersParams) ([]Customer, error) {
	rows, err := q.db.Query(ctx, getDeletedCustomers, arg.Ownerid, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Customer
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Updated,
			&i.Deleted,
			&i.FullName,
			&i.Email,
			&i.Phone,
			&i.Tags,
			&i.Note,
			&i.TaxExempt,
			&i.OwnerId,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeCustomerAddress = `-- name: RemoveCustomerAddress :exec
DELETE FROM "customersAddresses"
WHERE
  id = $1 AND
  "customerId" = $2
`

type RemoveCustomerAddressParams struct {
	ID         string `json:"id"`
	CustomerId string `json:"customerId"`
}

func (q *Queries) RemoveCustomerAddress(ctx context.Context, arg RemoveCustomerAddressParams) error {
	_, err := q.db.Exec(ctx, removeCustomerAddress, arg.ID, arg.CustomerId)
	return err
}

const saveCustomer = `-- name: SaveCustomer :one
INSERT INTO customers (
  id, updated, deleted, "fullName", 
  phone, tags, note, "taxExempt", "ownerId"
)
VALUES (
  $1,
  NOW(),
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8
)
ON CONFLICT (id)
DO UPDATE SET
  deleted = EXCLUDED.deleted,
  "fullName" = EXCLUDED.fullName,
  phone = EXCLUDED.phone,
  note = EXCLUDED.note,
  "taxExempt" = EXCLUDED.taxExempt
WHERE
  "ownerId" = $8
RETURNING id, created, updated, deleted, "fullName", email, phone, tags, note, "taxExempt", "ownerId"
`

type SaveCustomerParams struct {
	ID        string           `json:"id"`
	Deleted   pgtype.Timestamp `json:"deleted"`
	Fullname  string           `json:"fullname"`
	Phone     pgtype.Text      `json:"phone"`
	Tags      []string         `json:"tags"`
	Note      pgtype.Text      `json:"note"`
	Taxexempt bool             `json:"taxexempt"`
	Ownerid   string           `json:"ownerid"`
}

func (q *Queries) SaveCustomer(ctx context.Context, arg SaveCustomerParams) (Customer, error) {
	row := q.db.QueryRow(ctx, saveCustomer,
		arg.ID,
		arg.Deleted,
		arg.Fullname,
		arg.Phone,
		arg.Tags,
		arg.Note,
		arg.Taxexempt,
		arg.Ownerid,
	)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Updated,
		&i.Deleted,
		&i.FullName,
		&i.Email,
		&i.Phone,
		&i.Tags,
		&i.Note,
		&i.TaxExempt,
		&i.OwnerId,
	)
	return i, err
}

const setCustomerMainAddress = `-- name: SetCustomerMainAddress :one
WITH 
  current AS (
    SELECT id FROM "customersAddresses" 
    WHERE 
      "customersAddresses"."customerId" = $1 AND
      "customersAddresses".position = 0
  ),
  address AS (
    SELECT id, position FROM "customersAddresses"
    WHERE
      "customersAddresses".id = $2 AND
      "customersAddresses"."customerId" = $1
  )

UPDATE "customersAddresses"
SET
  position =
    CASE 
      WHEN id = address.id THEN 0
      WHEN id = current.id THEN address.position
    END
WHERE
  id IN (current.id, address.id)
RETURNING id, created, updated, name, company, country, state, city, zip, addresses, phone, "customerId", position
`

type SetCustomerMainAddressParams struct {
	CustomerId string `json:"customerId"`
	AddressId  string `json:"addressId"`
}

func (q *Queries) SetCustomerMainAddress(ctx context.Context, arg SetCustomerMainAddressParams) (CustomersAddress, error) {
	row := q.db.QueryRow(ctx, setCustomerMainAddress, arg.CustomerId, arg.AddressId)
	var i CustomersAddress
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Updated,
		&i.Name,
		&i.Company,
		&i.Country,
		&i.State,
		&i.City,
		&i.Zip,
		&i.Addresses,
		&i.Phone,
		&i.CustomerId,
		&i.Position,
	)
	return i, err
}

const softDeleteCustomer = `-- name: SoftDeleteCustomer :exec
UPDATE customers SET deleted = NOW()
WHERE
  "ownerId" = $1 AND
  (
    id = $2 OR
    email = $3
  )
`

type SoftDeleteCustomerParams struct {
	Ownerid string `json:"ownerid"`
	ID      string `json:"id"`
	Email   string `json:"email"`
}

func (q *Queries) SoftDeleteCustomer(ctx context.Context, arg SoftDeleteCustomerParams) error {
	_, err := q.db.Exec(ctx, softDeleteCustomer, arg.Ownerid, arg.ID, arg.Email)
	return err
}
