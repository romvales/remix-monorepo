// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: transactions.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countOrders = `-- name: CountOrders :one
SELECT
  (
    SELECT COUNT(*) FROM orders
    WHERE
      orders."shopId" = $1 AND
      deleted IS NULL
  ) "totalOrders",
  (
    SELECT COUNT(*) FROM orders
    WHERE
      orders."shopId" = $1 AND
      deleted IS NOT NULL
  ) "totalDeletedOrders"
`

type CountOrdersRow struct {
	TotalOrders        int64 `json:"totalOrders"`
	TotalDeletedOrders int64 `json:"totalDeletedOrders"`
}

func (q *Queries) CountOrders(ctx context.Context, shopid string) (CountOrdersRow, error) {
	row := q.db.QueryRow(ctx, countOrders, shopid)
	var i CountOrdersRow
	err := row.Scan(&i.TotalOrders, &i.TotalDeletedOrders)
	return i, err
}

const deleteOrder = `-- name: DeleteOrder :exec
DELETE FROM orders
WHERE
  id = $1 AND
  "shopId" = $2 AND
  deleted IS NULL
`

type DeleteOrderParams struct {
	ID     string `json:"id"`
	ShopId string `json:"shopId"`
}

func (q *Queries) DeleteOrder(ctx context.Context, arg DeleteOrderParams) error {
	_, err := q.db.Exec(ctx, deleteOrder, arg.ID, arg.ShopId)
	return err
}

const deleteTransaction = `-- name: DeleteTransaction :exec
DELETE FROM transactions
WHERE
  id = $1
`

func (q *Queries) DeleteTransaction(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteTransaction, id)
	return err
}

const getDeletedOrders = `-- name: GetDeletedOrders :many
SELECT id, created, updated, cancelled, closed, deleted, status, "fulfillmentStatus", "orderNumber", tags, note, currency, "totalPrice", subtotal, "totalTax", "totalShippingPrice", "shippingFee", "cancelReason", "shopId", "customerId", "shippingAddressId", "billingAddressId", "channelId" FROM orders
WHERE
  "shopId" = $1 AND
  deleted IS NOT NULL
LIMIT COALESCE($2, 10)
`

type GetDeletedOrdersParams struct {
	ShopId string      `json:"shopId"`
	Limit  interface{} `json:"limit"`
}

func (q *Queries) GetDeletedOrders(ctx context.Context, arg GetDeletedOrdersParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, getDeletedOrders, arg.ShopId, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Updated,
			&i.Cancelled,
			&i.Closed,
			&i.Deleted,
			&i.Status,
			&i.FulfillmentStatus,
			&i.OrderNumber,
			&i.Tags,
			&i.Note,
			&i.Currency,
			&i.TotalPrice,
			&i.Subtotal,
			&i.TotalTax,
			&i.TotalShippingPrice,
			&i.ShippingFee,
			&i.CancelReason,
			&i.ShopId,
			&i.CustomerId,
			&i.ShippingAddressId,
			&i.BillingAddressId,
			&i.ChannelId,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrder = `-- name: GetOrder :one
SELECT DISTINCT id, created, updated, cancelled, closed, deleted, status, "fulfillmentStatus", "orderNumber", tags, note, currency, "totalPrice", subtotal, "totalTax", "totalShippingPrice", "shippingFee", "cancelReason", "shopId", "customerId", "shippingAddressId", "billingAddressId", "channelId" FROM orders
WHERE
  "shopId" = $1 AND
  deleted IS NULL
LIMIT 1
`

func (q *Queries) GetOrder(ctx context.Context, shopid string) (Order, error) {
	row := q.db.QueryRow(ctx, getOrder, shopid)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Updated,
		&i.Cancelled,
		&i.Closed,
		&i.Deleted,
		&i.Status,
		&i.FulfillmentStatus,
		&i.OrderNumber,
		&i.Tags,
		&i.Note,
		&i.Currency,
		&i.TotalPrice,
		&i.Subtotal,
		&i.TotalTax,
		&i.TotalShippingPrice,
		&i.ShippingFee,
		&i.CancelReason,
		&i.ShopId,
		&i.CustomerId,
		&i.ShippingAddressId,
		&i.BillingAddressId,
		&i.ChannelId,
	)
	return i, err
}

const getOrders = `-- name: GetOrders :many
SELECT id, created, updated, cancelled, closed, deleted, status, "fulfillmentStatus", "orderNumber", tags, note, currency, "totalPrice", subtotal, "totalTax", "totalShippingPrice", "shippingFee", "cancelReason", "shopId", "customerId", "shippingAddressId", "billingAddressId", "channelId" FROM orders
WHERE
  "shopId" = $1 AND
  deleted IS NULL
LIMIT COALESCE($2, 10)
`

type GetOrdersParams struct {
	ShopId string      `json:"shopId"`
	Limit  interface{} `json:"limit"`
}

func (q *Queries) GetOrders(ctx context.Context, arg GetOrdersParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, getOrders, arg.ShopId, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Updated,
			&i.Cancelled,
			&i.Closed,
			&i.Deleted,
			&i.Status,
			&i.FulfillmentStatus,
			&i.OrderNumber,
			&i.Tags,
			&i.Note,
			&i.Currency,
			&i.TotalPrice,
			&i.Subtotal,
			&i.TotalTax,
			&i.TotalShippingPrice,
			&i.ShippingFee,
			&i.CancelReason,
			&i.ShopId,
			&i.CustomerId,
			&i.ShippingAddressId,
			&i.BillingAddressId,
			&i.ChannelId,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransaction = `-- name: GetTransaction :one
SELECT DISTINCT id, created, processed, kind, status, amount, currency, "gatewayId" FROM transactions
WHERE
  id = $1
LIMIT 1
`

func (q *Queries) GetTransaction(ctx context.Context, id string) (Transaction, error) {
	row := q.db.QueryRow(ctx, getTransaction, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Processed,
		&i.Kind,
		&i.Status,
		&i.Amount,
		&i.Currency,
		&i.GatewayId,
	)
	return i, err
}

const getTransactions = `-- name: GetTransactions :many
SELECT id, created, processed, kind, status, amount, currency, "gatewayId" FROM transactions
WHERE
  deleted IS NULL AND
  id = $1
LIMIT COALESCE($2, 10)
`

type GetTransactionsParams struct {
	ID    string      `json:"id"`
	Limit interface{} `json:"limit"`
}

func (q *Queries) GetTransactions(ctx context.Context, arg GetTransactionsParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, getTransactions, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Processed,
			&i.Kind,
			&i.Status,
			&i.Amount,
			&i.Currency,
			&i.GatewayId,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveOrder = `-- name: SaveOrder :one
INSERT INTO orders (
  id, updated, deleted, cancelled, closed,
  status, "fulfillmentStatus", "orderNumber",
  tags, note, currency,

  "totalPrice", subtotal, "totalTax", "totalShippingPrice",
  "shippingFee",

  "cancelReason",

  "shopId", "customerId", "shippingAddressId", "billingAddressId" 
)
VALUES (
  $1, NOW(), $2, $3, $4,
  $5, $6, $7,
  $8, $9, $10, $11, $12,
  $13, $14, $15,
  $16,

  $17, $18, $19,
  $20
)
ON CONFLICT (id)
DO UPDATE SET
  deleted = EXCLUDED.deleted,
  cancelled = EXCLUDED.cancelled,
  closed = EXCLUDED.closed,
  status = EXCLUDED.status,
  "fulfillmentStatus" = EXCLUDED."fulfillmentStatus",
  "orderNumber" = EXCLUDED."orderNumber",
  tags = EXCLUDED.tags,
  note = EXCLUDED.note,
  currency = EXCLUDED.currency,
  
  "totalPrice" = EXCLUDED."totalPrice",
  subtotal = EXCLUDED.subtotal,
  "totalTax" = EXCLUDED."totalTax",
  "totalShippingPrice" = EXCLUDED."totalShippingPrice",
  "shippingFee" = EXCLUDED."shippingFee",

  "cancelReason" = EXCLUDED."cancelReason",

  "shopId" = EXCLUDED."shopId",
  "customerId" = EXCLUDED."customerId",
  "shippingAddressId" = EXCLUDED."shippingAddressId",
  "billingAddressId" = EXCLUDED."billingAddressId" 
RETURNING id, created, updated, cancelled, closed, deleted, status, "fulfillmentStatus", "orderNumber", tags, note, currency, "totalPrice", subtotal, "totalTax", "totalShippingPrice", "shippingFee", "cancelReason", "shopId", "customerId", "shippingAddressId", "billingAddressId", "channelId"
`

type SaveOrderParams struct {
	ID                 string            `json:"id"`
	Deleted            pgtype.Timestamp  `json:"deleted"`
	Cancelled          pgtype.Timestamp  `json:"cancelled"`
	Closed             pgtype.Timestamp  `json:"closed"`
	Status             OrderStatus       `json:"status"`
	FulfillmentStatus  FulfillmentStatus `json:"fulfillmentStatus"`
	OrderNumber        string            `json:"orderNumber"`
	Tags               []string          `json:"tags"`
	Note               pgtype.Text       `json:"note"`
	Currency           string            `json:"currency"`
	TotalPrice         pgtype.Numeric    `json:"totalPrice"`
	Subtotal           pgtype.Numeric    `json:"subtotal"`
	TotalTax           pgtype.Numeric    `json:"totalTax"`
	TotalShippingPrice float64           `json:"totalShippingPrice"`
	ShippingFee        float64           `json:"shippingFee"`
	CancelReason       pgtype.Text       `json:"cancelReason"`
	ShopId             string            `json:"shopId"`
	CustomerId         pgtype.Text       `json:"customerId"`
	ShippingAddressId  pgtype.Text       `json:"shippingAddressId"`
	BillingAddressId   pgtype.Text       `json:"billingAddressId"`
}

func (q *Queries) SaveOrder(ctx context.Context, arg SaveOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, saveOrder,
		arg.ID,
		arg.Deleted,
		arg.Cancelled,
		arg.Closed,
		arg.Status,
		arg.FulfillmentStatus,
		arg.OrderNumber,
		arg.Tags,
		arg.Note,
		arg.Currency,
		arg.TotalPrice,
		arg.Subtotal,
		arg.TotalTax,
		arg.TotalShippingPrice,
		arg.ShippingFee,
		arg.CancelReason,
		arg.ShopId,
		arg.CustomerId,
		arg.ShippingAddressId,
		arg.BillingAddressId,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Updated,
		&i.Cancelled,
		&i.Closed,
		&i.Deleted,
		&i.Status,
		&i.FulfillmentStatus,
		&i.OrderNumber,
		&i.Tags,
		&i.Note,
		&i.Currency,
		&i.TotalPrice,
		&i.Subtotal,
		&i.TotalTax,
		&i.TotalShippingPrice,
		&i.ShippingFee,
		&i.CancelReason,
		&i.ShopId,
		&i.CustomerId,
		&i.ShippingAddressId,
		&i.BillingAddressId,
		&i.ChannelId,
	)
	return i, err
}

const saveTransaction = `-- name: SaveTransaction :one
INSERT INTO transactions (
  id, processed, kind, status, amount, currency, "gatewayId"
)
VALUES (
  $1, $2, $3, $4, $5, $6,
  $7
)
ON CONFLICT (id)
DO UPDATE SET
  processed = EXCLUDED.processed,
  kind = EXCLUDED.kind,
  status = EXCLUDED.status,
  amount = EXCLUDED.amount,
  currency = EXCLUDED.currency,
  "gatewayId" = EXCLUDED."gatewayId"
RETURNING id, created, processed, kind, status, amount, currency, "gatewayId"
`

type SaveTransactionParams struct {
	ID        string            `json:"id"`
	Processed pgtype.Timestamp  `json:"processed"`
	Kind      TransactionKind   `json:"kind"`
	Status    TransactionStatus `json:"status"`
	Amount    pgtype.Numeric    `json:"amount"`
	Currency  string            `json:"currency"`
	GatewayId pgtype.Text       `json:"gatewayId"`
}

func (q *Queries) SaveTransaction(ctx context.Context, arg SaveTransactionParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, saveTransaction,
		arg.ID,
		arg.Processed,
		arg.Kind,
		arg.Status,
		arg.Amount,
		arg.Currency,
		arg.GatewayId,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Processed,
		&i.Kind,
		&i.Status,
		&i.Amount,
		&i.Currency,
		&i.GatewayId,
	)
	return i, err
}

const softDeleteOrder = `-- name: SoftDeleteOrder :exec
UPDATE orders SET deleted = NOW()
WHERE
  id = $1 AND
  "shopId" = $2
`

type SoftDeleteOrderParams struct {
	ID     string `json:"id"`
	ShopId string `json:"shopId"`
}

func (q *Queries) SoftDeleteOrder(ctx context.Context, arg SoftDeleteOrderParams) error {
	_, err := q.db.Exec(ctx, softDeleteOrder, arg.ID, arg.ShopId)
	return err
}

const softDeleteTransaction = `-- name: SoftDeleteTransaction :exec
UPDATE transactions SET deleted = NOW()
WHERE
  id = $1
`

func (q *Queries) SoftDeleteTransaction(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, softDeleteTransaction, id)
	return err
}
